= Register Description File
:sectnums:
:toc:
:toclevels: 4

Register Explorer uses a register description file to provide a hierarchical view into the design under test (DUT).

The register description files use YAML syntax, and must have either a `.yml` or `.yaml` file extension.
If you're new to YAML and want to learn more, see "https://learnxinyminutes.com/docs/yaml/Learn[YAML in Y minutes]."

Register description files are intended to be generated via a register automation solution.

[source,yaml]
.Small complete example
----
schema:
  name: register-description-format
  version: v0.2

root:
  display_name: Example Design
  version: v1.0
  links:
    GitHub: https://github.com/org/repo
  children:
    - blk0

elements:
  blk0:
    type: blk
    id: blk0
    name: blk0
    children:
      - blk0.reg0
      - blk0.reg1

  blk0.reg0:
    id: blk0.reg0
    type: reg
    name: reg0
    offset: 0x0
    doc: An example register.
    fields:
      - name: rsvd
        lsb: 5
        nbits: 28
        access: rw
        doc: A reserved field.
      - name: command
        lsb: 0
        nbits: 4
        access: rw
        doc: The command to execute.
        enum:
          - name: START
            value: 0x5
            doc: Starts the operation.
          - name: STOP
            value: 0xA
            doc: Stops the operation.

  blk0.reg1:
    type: reg
    id: blk0.reg1
    name: reg1
    data_width: 16
    offset: 0x4
    fields:
      - name: f0
        lsb: 0
        nbits: 16
        access: ro
        reset: 0x0
----

== Document Top Level

The document top level is an object with the following properties:

* `schema` -- Specifies schema version information.
Required.
Type: object.
* `root` -- Specifies the top level design elements.
Required.
Type: object.
* `elements` -- Defines all design elements and their relationships.
Required.
Type: object.

== `schema` Property

The `schema` property specifies the version of the register schema used by the document.

[source,yaml]
.`schema` snippet
----
schema:
  name: register-description-format
  version: v0.2
----

The `schema` property is an object with the following properties:

* `name` -- Specifies the name of the schema that the RDF JSON targets.
Required.
Type: string.
The value must be `register-description-format`.

* `version` -- Specifies the version of the schema that the RDF JSON targets.
Required.
Type: string.
The value must be `v0.2` or `v0.2.x` where x is any positive integer.

== Element IDs

Element IDs uniquely identify elements.

=== Hierarchy

By convention, hierarchy is denoted via the `.` character.

For example, the element ID `regs.blk0.reg0` has the following hierarchy:

[listing]
----
regs
└── blk0
    └── reg0
----

== `root` Property

The `root` property is an object that specifies the design top level as a block element.

The `root` property object supports all of the properties of <<block-elements>> with some differences.

The following block element properties are not valid for the `root` property object:

* `offset` -- The `element.offset` property is not valid in the `root` property object.

The following optional block element properties are required for the `root` property object:

* `display_name` -- Required for `root`

[source,yaml]
.`root` snippet
----
root:
  display_name: Example Design
  version: v1.0
  links:
    GitHub: https://github.com/org/repo
  children:
    - element0
    - element1
----

== `elements` Property

The `elements` property defines all design elements and their hierarchy.

Elements are specified in a flat map indexed by element ID.
Elements can reference other elements by their element ID to create a describe a tree structure.

There are four element types.

* Block (`blk`)
* Register (`reg`)
* Memory (`mem`)
* Include (`include`)

The element type is specified via the `type` property.

All elements support the following keys:

* `id` -- A copy of the element ID.
Must be unique.
One convention is to concatenate hierarchical element names (e.g. `blk.sub_blk.reg`).
Required.
* `name` -- The name of the element.
Must be a valid C language identifier.
Meant for human and machine consumption.
Required.
* `display_name` -- The name of the element meant for human consumption.
Optional.
* `type` -- One of `blk`, `mem`, or `reg`
Required.
* `offset`: The offset (bytes) of the element relative to its parent.
Required.
* `doc` -- Documentation for the element.
Supports HTML.
Optional.
* `data_width` -- Specifies the size of register elements in bits.
Applies to all children unless overwritten by a child element.
Optional.
Default: 32.
Type: number.
Possible values: 16, 32.
* `default_reset` -- The name used for a reset when `field.reset` is specified as a scalar.
Applies to all children unless overwritten by a child element.
Optional.
Type: string.
Default: "Default".

[#block-elements]
=== Block Elements (`blk`)

Block elements are a grouping of other elements.
They are identified as blocks via the `type: blk` key-value pair.
Block elements can contain `reg`, `mem`, and other `blk` elements.
They have the following keys:

* `type`: `blk`
* `version` -- the block version
Optional.
* `links` -- relevant links (text/URI pairs)
Optional.
* `size`: The size (bytes) of the block.
Optional.
* `children`: A sequence of element IDs.

[source,yaml]
.Block element example
----
block0:
  id: block0
  name: block0
  type: blk
  offset: 0x0
  size: 0x1000
  children:
    - block1
    - reg0
    - mem0
----

=== Register Elements (`reg`)

Register elements describe 32-bit hardware registers.
They are identified as registers via the `type: reg` key-value pair.
They have the following keys:

* `type`: `reg`
* `fields`: A sequence of Field objects.

==== Field Objects

Field objects describe an n-bit register field.
They have the following keys:

* `name`: The name of the field.
Required.
* `nbits`: The size of the field in bits.
Required.
* `lsb`: The index of the least significant bit of the field relative to the register.
Required.
* `access`: The software access type of the field.
Required.
* `reset`: The reset definition of the field.
Type: number or string or object.
Strings values can be binary (`0b` prefix), decimal (no prefix), or hexadecimal (`0x` prefix).
Object values are used to specify multiple resets or a non-default reset.
Object values are in the form of `{ "value": scalar, "resets": ["name_a", "name_b", ...] }`.
If no reset name is specified, the name specified by `default_reset` is used.
Optional.
* `doc`: The documentation for the field.
Supports HTML.
Optional.
* `enum`: An array of EnumValue objects
Optional.

The following properties are experimental and are subject to change:

* `repr`: The default representation.
Default: `hex`.
Optional.
** `bin`: Binary (e.g. `0b0101`)
** `dec`: Decimal (e.g. `5`)
** `hex`: Hexadecimal (e.g. `0x5`)

* `custom_decode`: Custom decode function to apply.
Default: None.
Optional.

* `custom_encode`: Custom decode function to apply.
Default: None.
Optional.

===== EnumValue Objects

Enum value objects describe a single enumerated value.
They have the following properties:

* `name`: The symbolic name of the enumerated value.
Required.
* `value`: The numeric value of the enumerated value.
Required.
Type: number or string.
* `doc`: The documentation for the enumerated value.
HTML supported.
Optional.

==== Register Element Example

[source,yaml]
.Register element example
----
blk0.reg0:
  id: blk0.reg0
  type: reg
  name: reg0
  offset: 0x0
  doc: An example register.
  fields:
    - name: rsvd
      lsb: 5
      nbits: 28
      access: rw
      doc: A reserved field.
    - name: command
      lsb: 0
      nbits: 4
      access: rw
      doc: The command to execute.
      enum:
        - name: START
          value: 0x5
          doc: Starts the operation.
        - name: STOP
          value: 0xA
          doc: Stops the operation.
----

=== Memory Elements (`mem`)

Memory elements describe contiguous blocks of memory.
They are identified as memories via the `type: mem` key-value pair.
They have the following keys:

* `type`: `mem`
* `id` -- A copy of the element ID.
Must be unique.
One convention is to concatenate hierarchical element names (e.g. `blk.sub_blk.reg`).
Required.
* `name` -- The name of the element.
Must be a valid C language identifier.
Meant for human and machine consumption.
Required.
* `size`: The size (bytes) of the memory.

=== Include Elements (`include`)

Include elements are used to include other RDF files.

They have the following properties:

* `type` -- `include`
* `id` -- A copy of the element ID.
Must be unique.
One convention is to concatenate hierarchical element names (e.g. `blk.sub_blk.reg`).
Required.
* `name` -- The name of the element.
Must be a valid C language identifier.
Meant for human and machine consumption.
Required.
* `offset` -- The offset (bytes) of the element relative to its parent.
Optional.
* `url` -- The URL to the RDF JSON to be included.

==== Include Semantics

Includes work by effectively merging the `root` property of the included JSON into the include element and changing the include element type to `blk`.
